package org.example.business.workers;

import org.example.config.Configuration;
import org.example.config.SubscriptionWorkerConfig;
import org.example.models.enums.Field;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

public class SubscriptionWorkerManager {
    public static void generateSubscriptions(Configuration config) throws InterruptedException {
        var latch = new CountDownLatch(1);
        var subscriptionWorkers = new ArrayList<SubscriptionWorker>();
        for (var i = 0; i < config.threadCount(); i++) {
            var subWorkerConfig = getSubscriptionWorkerConfig(config, i);
            var subscriptionWorker = new SubscriptionWorker("Subscription worker " + i, latch, config, subWorkerConfig);
            subscriptionWorker.start();
            subscriptionWorkers.add(subscriptionWorker);
        }

        latch.countDown();

        System.out.println("Subscriptions:");
        for (var subscriptionWorker : subscriptionWorkers) {
            subscriptionWorker.join();
            for (var sub : subscriptionWorker.getSubscriptions()) {
                System.out.println(sub);
            }
        }
    }

    private static SubscriptionWorkerConfig getSubscriptionWorkerConfig(Configuration config, int index) {
        var subWorkerConfig = new SubscriptionWorkerConfig();

        // subs to be generated by worker
        int quantum = config.subscriptionCount() / config.threadCount();
        if (index == config.threadCount() - 1) {
            quantum += config.subscriptionCount() % config.threadCount();
        }
        subWorkerConfig.setQuantum(quantum);

        // mandatory field counts
        var withFieldCounts = getWithCounts(config.weights(),
                config.subscriptionCount(),
                config.threadCount(),
                index);
        subWorkerConfig.setWithFieldsCounts(withFieldCounts);

        // mandatory equal counts
        var withEqualCounts = getWithCounts(config.equalFrequencyMinimums(),
                config.subscriptionCount(),
                config.threadCount(),
                index);
        subWorkerConfig.setWithEqualCounts(withEqualCounts);

        return subWorkerConfig;
    }

    private static Map<Field, Integer> getWithCounts(Map<Field, Double> weights, int total, int workerCount, int index) {
        var withCounts = new HashMap<Field, Integer>();
        for (var weight : weights.entrySet()) {
            var field = weight.getKey();
            var totalWith = (int) Math.ceil(total * weight.getValue());
            int withCount = totalWith / workerCount;
            // the last worker also gets the remainder
            if(index == workerCount - 1) {
                withCount += totalWith % workerCount;
            }
            withCounts.put(field, withCount);
        }

        return withCounts;
    }
}
