package org.example.business.workers;

import org.example.business.services.FileLogger;
import org.example.config.Configuration;
import org.example.config.SubscriptionWorkerConfig;
import org.example.models.Subscription;
import org.example.models.enums.Field;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.stream.Stream;

public class SubscriptionWorkerManager {
    public static List<Subscription> generateSubscriptions(Configuration config, FileLogger fileLogger) throws InterruptedException, IOException {
        var latch = new CountDownLatch(1);
        var subscriptionWorkers = new ArrayList<SubscriptionWorker>();
        for (var i = 0; i < config.threadCount(); i++) {
            var subWorkerConfig = getSubscriptionWorkerConfig(config, i);
            var subscriptionWorker = new SubscriptionWorker("Subscription worker " + i, latch, config, subWorkerConfig);
            subscriptionWorker.start();
            subscriptionWorkers.add(subscriptionWorker);
        }

        var startTime = System.currentTimeMillis();
        latch.countDown();

        List<Subscription> totalSubscriptions = new ArrayList<>();
        for (var subscriptionWorker : subscriptionWorkers) {
            subscriptionWorker.join();
            totalSubscriptions = Stream.concat(totalSubscriptions.stream(), subscriptionWorker.getSubscriptions().stream()).toList();
        }

        var endTime = System.currentTimeMillis();

        fileLogger.log("Subscriptions:").newLine();
        fileLogger.log("Generation time: ").logTime(startTime, endTime).newLine();
        fileLogger.logList(totalSubscriptions).newLine();

        return totalSubscriptions;
    }

    private static SubscriptionWorkerConfig getSubscriptionWorkerConfig(Configuration config, int index) {
        var subWorkerConfig = new SubscriptionWorkerConfig();

        // subs to be generated by worker
        int quantum = config.subscriptionCount() / config.threadCount();
        if (index == config.threadCount() - 1) {
            quantum += config.subscriptionCount() % config.threadCount();
        }
        subWorkerConfig.setQuantum(quantum);

        // mandatory field counts
        var withFieldCounts = getWithCounts(config.weights(),
                config.subscriptionCount(),
                config.threadCount(),
                index);
        subWorkerConfig.setWithFieldsCounts(withFieldCounts);

        // mandatory equal counts
        var withEqualCounts = getWithCounts(config.equalFrequencyMinimums(),
                config.subscriptionCount(),
                config.threadCount(),
                index);
        subWorkerConfig.setWithEqualCounts(withEqualCounts);

        return subWorkerConfig;
    }

    private static Map<Field, Integer> getWithCounts(Map<Field, Double> weights, int total, int workerCount, int index) {
        var withCounts = new HashMap<Field, Integer>();
        for (var weight : weights.entrySet()) {
            var field = weight.getKey();
            var totalWith = (int) Math.ceil(total * weight.getValue());
            int withCount = totalWith / workerCount;
            // the last worker also gets the remainder
            if(index == workerCount - 1) {
                withCount += totalWith % workerCount;
            }
            withCounts.put(field, withCount);
        }

        return withCounts;
    }
}
